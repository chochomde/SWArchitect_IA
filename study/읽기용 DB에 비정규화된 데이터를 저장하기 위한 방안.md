### 설계 전략 제목: 읽기용 DB에 비정규화된 데이터를 저장하기 위한 방안

#### 설계 전략 선정 이유

비정규화된 데이터를 NoSQL 데이터베이스에 저장함으로써 조회 성능을 극대화하고, CUD 트랜잭션은 RDBMS에서 처리하여 데이터 일관성과 무결성을 유지합니다. 이를 위해 두 데이터베이스 간의 효율적인 데이터 동기화 전략이 필요합니다. 세 가지 주요 전략을 비교하여 가장 적합한 방법을 선정합니다: CDC(Change Data Capture), 배치 작업, 그리고 이벤트 소싱과 CQRS 패턴.

### 설계 전략 상세

#### 전략 1: Change Data Capture (CDC) 기반 동기화

**선정 이유:** CDC는 RDBMS에서 발생하는 데이터 변경 이벤트를 캡처하여 NoSQL 데이터베이스로 실시간으로 동기화할 수 있는 강력한 방법입니다.

**구현 방법:**

1. **CDC 도구 선택:** Debezium, Oracle GoldenGate, AWS Database Migration Service 등과 같은 CDC 도구를 선택합니다.
2. **변경 이벤트 캡처:** RDBMS에서 발생하는 삽입, 업데이트, 삭제 이벤트를 캡처합니다.
3. **이벤트 스트리밍:** 캡처된 이벤트를 Kafka, AWS Kinesis 등과 같은 스트리밍 플랫폼으로 전달합니다.
4. **데이터 변환:** 스트리밍된 이벤트를 적절한 형식으로 변환합니다. 예를 들어, JSON 형식으로 변환하여 NoSQL 데이터베이스에 적합하게 만듭니다.
5. **NoSQL DB로 적용:** 변환된 데이터를 NoSQL 데이터베이스로 저장합니다. 이때, NoSQL 데이터베이스의 API를 사용하여 비정규화된 데이터 구조에 맞게 데이터를 삽입하거나 업데이트합니다.
6. **모니터링 및 장애 처리:** 데이터 동기화 상태를 지속적으로 모니터링하고, 장애 발생 시 자동 복구 메커니즘을 마련합니다.

**장점:**

- **실시간 동기화:** 데이터 변경이 발생하는 즉시 NoSQL DB에 반영되어 최신 상태를 유지할 수 있습니다.
- **확장성:** 스트리밍 플랫폼을 사용하여 대량의 데이터 변경 이벤트를 효율적으로 처리할 수 있습니다.

**단점:**

- **복잡성:** 설정과 운영이 복잡할 수 있으며, CDC 도구와 스트리밍 플랫폼의 추가 관리가 필요합니다.

#### 전략 2: 주기적 배치 작업 기반 동기화

**선정 이유:** 주기적 배치 작업은 설정이 비교적 간단하며, 트래픽이 적은 시간에 동기화를 수행하여 시스템 부하를 최소화할 수 있습니다.

**구현 방법:**

1. **배치 스케줄러 설정:** Cron, Quartz Scheduler 등과 같은 배치 스케줄러를 설정하여 주기적으로 동기화 작업을 실행합니다.
2. **데이터 추출:** RDBMS에서 변경된 데이터를 추출합니다. 이를 위해 타임스탬프 또는 로그 테이블을 사용하여 변경된 레코드를 식별합니다.
3. **데이터 변환:** 추출된 데이터를 NoSQL 데이터베이스에 맞는 형식으로 변환합니다.
4. **NoSQL DB로 적용:** 변환된 데이터를 NoSQL 데이터베이스에 삽입하거나 업데이트합니다.
5. **동기화 검증:** 동기화 후 데이터 일관성을 검증하여 오류가 발생한 데이터를 재처리합니다.

**장점:**

- **간단한 설정:** 비교적 간단한 설정과 운영이 가능하며, 추가적인 인프라가 필요 없습니다.
- **부하 관리:** 주기적으로 동기화를 수행함으로써 시스템 부하를 조절할 수 있습니다.

**단점:**

- **실시간성 부족:** 실시간 동기화가 아닌 주기적인 동기화이기 때문에 데이터가 최신 상태를 항상 반영하지 않을 수 있습니다.
- **잠재적 데이터 불일치:** 동기화 주기 동안 발생한 변경 사항이 NoSQL DB에 즉시 반영되지 않을 수 있습니다.

#### 전략 3: 이벤트 소싱과 CQRS 패턴 기반 동기화

**선정 이유:** 이벤트 소싱과 CQRS 패턴은 애플리케이션 레벨에서 데이터 변경을 추적하고, 비정규화된 데이터를 효율적으로 동기화할 수 있는 방법입니다.

**구현 방법:**

1. **CQRS 패턴 적용:**
   - **명령 모델 (Command Model):** 데이터 변경 작업(CUD)을 처리하는 모델입니다. 이 모델은 RDBMS를 사용하여 데이터 일관성을 유지합니다.
   - **조회 모델 (Query Model):** 조회 작업을 처리하는 모델입니다. 이 모델은 비정규화된 데이터를 저장하는 NoSQL 데이터베이스를 사용하여 빠른 조회 성능을 제공합니다.
2. **이벤트 소싱:**
   - **이벤트 저장소:** 모든 상태 변경을 이벤트로 저장합니다. 이벤트는 도메인 이벤트로 표현되며, 이벤트 저장소에 기록됩니다.
   - **이벤트 발행:** 상태 변경이 발생할 때마다 이벤트를 발행합니다. 이벤트는 메시지 브로커(예: Kafka, RabbitMQ)를 통해 전송될 수 있습니다.
3. **이벤트 핸들러:**
   - **명령 처리:** 명령 모델에서 데이터 변경이 발생하면 이벤트를 생성하고 저장소에 저장한 후, 해당 이벤트를 발행합니다.
   - **조회 모델 업데이트:** 조회 모델은 발행된 이벤트를 구독하고, 이를 기반으로 비정규화된 데이터를 업데이트합니다. 이를 통해 조회 모델은 항상 최신 상태를 반영합니다.
4. **데이터 동기화:**
   - **이벤트 기반 동기화:** 이벤트 저장소에 저장된 이벤트를 기반으로 NoSQL 데이터베이스에 비정규화된 데이터를 동기화합니다.
   - **이벤트 재생:** 필요에 따라 이벤트를 재생하여 조회 모델을 재구성할 수 있습니다. 이는 시스템 복구나 새로운 조회 모델을 추가할 때 유용합니다.

**장점:**

- **명확한 책임 분리:** CQRS 패턴을 통해 명령과 조회의 책임을 명확히 분리하여 코드의 가독성과 유지보수성을 높입니다.
- **실시간 동기화:** 이벤트 기반 아키텍처를 통해 데이터 변경을 실시간으로 반영할 수 있습니다.
- **확장성:** 이벤트 소싱을 통해 시스템의 확장성과 복구 능력을 극대화할 수 있습니다.

**단점:**

- **복잡성:** 이벤트 소싱과 CQRS 패턴의 구현과 운영이 복잡할 수 있습니다.
- **이벤트 일관성 관리:** 이벤트의 일관성을 유지하고, 이벤트 재생 시 정확한 순서를 보장하는 것이 중요합니다.

### 결론

**CDC 기반 동기화**, **주기적 배치 작업 기반 동기화**, 그리고 **이벤트 소싱과 CQRS 패턴 기반 동기화**는 각각의 장단점을 가지고 있습니다.

- **CDC 기반 동기화**는 실시간 동기화를 통해 최신 데이터를 유지할 수 있지만, 설정과 운영이 복잡할 수 있습니다.
- **주기적 배치 작업 기반 동기화**는 설정이 간단하고 시스템 부하를 조절할 수 있지만, 실시간성이 부족하여 데이터가 최신 상태를 항상 반영하지 못할 수 있습니다.
- **이벤트 소싱과 CQRS 패턴 기반 동기화**는 애플리케이션 레벨에서 데이터 변경을 효과적으로 관리하고, 실시간 동기화를 보장하지만, 구현과 운영이 복잡할 수 있습니다.

시스템 요구사항과 운영 환경에 맞춰 적절한 동기화 전략을 선택하는 것이 중요합니다. 실시간 데이터 일관성이 중요한 경우 CDC 기반 동기화 또는 이벤트 소싱과 CQRS 패턴을, 설정과 운영의 간편함이 중요한 경우 주기적 배치 작업 기반 동기화를 선택할 수 있습니다.